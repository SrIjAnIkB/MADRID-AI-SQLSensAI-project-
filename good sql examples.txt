10 GOOD SQL/SCHEMA EXAMPLES (proper indexes, efficient joins, avoiding redundant scans)
 
-- 1) Proper index on filter columns -> avoids full table scan on orders
--   Good: composite index to support (customer_id, order_date) filter and order_date range.
CREATE INDEX IF NOT EXISTS idx_orders_customer_date
    ON orders(customer_id, order_date);
 
SELECT
    o.order_id,
    o.order_date,
    o.customer_id,
    o.total_amount
FROM orders o
WHERE o.customer_id = 12345
  AND o.order_date >= DATE '2025-01-01';
 
 
-- 2) Composite index aligned with WHERE + ORDER BY
--   Good: index (status, created_at DESC) to support this query pattern.
CREATE INDEX IF NOT EXISTS idx_users_status_created
    ON users(status, created_at DESC);
 
SELECT
    u.user_id,
    u.email,
    u.status,
    u.created_at
FROM users u
WHERE u.status = 'ACTIVE'
  AND u.created_at >= NOW() - INTERVAL '7 days'
ORDER BY u.created_at DESC;
 
 
-- 3) Replace correlated subquery with JOIN + GROUP BY
--   Good: orders table scanned once, grouped by customer_id.
SELECT
    c.customer_id,
    c.name,
    COALESCE(o.recent_order_count, 0) AS recent_order_count
FROM customers c
LEFT JOIN (
    SELECT
        o.customer_id,
        COUNT(*) AS recent_order_count
    FROM orders o
    WHERE o.order_date >= CURRENT_DATE - INTERVAL '30 days'
    GROUP BY o.customer_id
) o
  ON o.customer_id = c.customer_id
WHERE c.status = 'ACTIVE';
 
 
-- 4) Preserve index usability by not wrapping indexed columns in functions
--   Good: use a range predicate instead of DATE() on order_date.
--   Assumes index on orders(order_date).
CREATE INDEX IF NOT EXISTS idx_orders_order_date
    ON orders(order_date);
 
SELECT
    o.order_id,
    o.order_date,
    o.total_amount
FROM orders o
WHERE o.order_date >= TIMESTAMP '2025-12-01 00:00:00'
  AND o.order_date <  TIMESTAMP '2025-12-02 00:00:00';
 
 
-- 5) Sufficient join condition in multi-tenant schema
--   Good: join on both department_id and tenant_id to avoid cross-tenant matches.
CREATE INDEX IF NOT EXISTS idx_employees_tenant_dept
    ON employees(tenant_id, department_id);
 
CREATE INDEX IF NOT EXISTS idx_departments_tenant_dept
    ON departments(tenant_id, department_id);
 
SELECT
    e.employee_id,
    e.name,
    d.department_name
FROM employees e
JOIN departments d
  ON e.department_id = d.department_id
AND e.tenant_id     = d.tenant_id;
 
 
-- 6) Proper INNER JOIN instead of CROSS JOIN + filter
--   Good: avoids unnecessary cartesian product.
CREATE INDEX IF NOT EXISTS idx_orders_customer_date2
    ON orders(customer_id, order_date);
 
SELECT
    c.customer_id,
    c.name,
    o.order_id,
    o.total_amount
FROM customers c
JOIN orders o
  ON c.customer_id = o.customer_id
WHERE o.order_date >= CURRENT_DATE - INTERVAL '7 days';
 
 
-- 7) Join on matching types / keys to use indexes
--   Good: fact table stores date_key that matches dim_date.date_key.
CREATE INDEX IF NOT EXISTS idx_fact_sales_date_key
    ON fact_sales(date_key);
 
CREATE INDEX IF NOT EXISTS idx_dim_date_date_key
    ON dim_date(date_key);
 
SELECT
    f.date_key,
    f.sales_amount,
    d.calendar_date
FROM fact_sales f
JOIN dim_date d
  ON f.date_key = d.date_key
WHERE d.calendar_date BETWEEN DATE '2025-01-01' AND DATE '2025-01-31';
 
 
-- 8) Simple, direct query instead of redundant self-join
--   Good: only one scan of users table.
CREATE INDEX IF NOT EXISTS idx_users_status
    ON users(status);
 
SELECT
    u.user_id,
    u.email
FROM users u
WHERE u.status = 'ACTIVE';
 
 
-- 9) Single, purposeful index instead of duplicates
--   Good: one index on orders(customer_id) used by many queries.
CREATE INDEX IF NOT EXISTS idx_orders_customer_id
    ON orders(customer_id);
 
SELECT
    o.order_id,
    o.order_date,
    o.total_amount
FROM orders o
WHERE o.customer_id = 98765
ORDER BY o.order_date DESC;
 
 
-- 10) Thoughtful composite index design to minimize redundancy
--   Good: one carefully chosen composite index that covers main use cases.
--   Example: most queries filter by (user_id, status) and sort/filter by created_at.
CREATE INDEX IF NOT EXISTS idx_payments_user_status_created
    ON payments(user_id, status, created_at);
 
SELECT
    p.payment_id,
    p.user_id,
    p.status,
    p.created_at,
    p.amount
FROM payments p
WHERE p.user_id = 42
  AND p.status  = 'COMPLETED'
  AND p.created_at >= NOW() - INTERVAL '30 days'
ORDER BY p.created_at DESC;